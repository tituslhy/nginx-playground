# ---------- events ----------
events {
    # Each worker can handle up to 1024 simultaneous client connections.
    # This controls concurrency, not total throughput.
    worker_connections 1024;
}

# ---------- http ----------
http {
    # ðŸ”¹ Dynamic DNS Resolver for Docker
    # Dockerâ€™s internal DNS server is always at 127.0.0.11
    # "valid=10s" means cache each resolved IP for 10 seconds.
    # "ipv6=off" prevents unnecessary lookups since Docker usually runs IPv4-only.
    resolver 127.0.0.11 valid=10s ipv6=off;

    # ðŸ”¹ Smart "Connection" Header Mapping
    # When a client starts a WebSocket, it sends:
    #   Upgrade: websocket
    #   Connection: Upgrade
    # When itâ€™s a normal HTTP request, it doesnâ€™t.
    #
    # If we blindly set Connection "upgrade" for all requests,
    # normal HTTP requests break because theyâ€™ll try to "upgrade" to something nonexistent.
    #
    # The map block dynamically sets $connection_upgrade to "upgrade" *only when*
    # the client actually sends an Upgrade header.
    map $http_upgrade $connection_upgrade {
        default upgrade;
        ''      close;
    }

    # ---------- upstream: backend load balancing ----------
    upstream chainlit_app {
        # Shared zone stores connection state across worker processes
        # (so load balancing decisions stay consistent)
        zone chainlit_zone 64k;

        # Point to the Docker service name "chainlit"
        # The 'resolve' keyword ensures Nginx re-resolves the hostname using
        # the resolver defined above â€” critical for dynamic Docker environments.
        server chainlit:8000 resolve;

        # Load balancing method:
        # Default is round-robin, but we can pick one explicitly:
        # least_conn;     # send new requests to backend with least active connections
        ip_hash;          # send all requests from the same client IP to the same backend (sticky sessions)
        # hash $request_uri; # deterministic hash, good for cache sharding or custom routing
    }

    # ---------- server (virtual host) ----------
    server {
        listen 8080;

        location / {
            # Proxy all traffic to the upstream defined above
            proxy_pass http://chainlit_app;

            # --- Forwarded Headers ---
            proxy_set_header Host $host;                     # original host (e.g. localhost:8080)
            proxy_set_header X-Real-IP $remote_addr;         # client IP as seen by Nginx
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # full chain of proxies
            proxy_set_header X-Forwarded-Proto $scheme;      # http or https

            # --- WebSocket Support ---
            proxy_http_version 1.1;                          # required for WebSocket + keep-alive
            proxy_set_header Upgrade $http_upgrade;          # carry through the Upgrade header
            proxy_set_header Connection $connection_upgrade; # dynamic "upgrade" or "close" from map

            # --- Connection Stability ---
            proxy_connect_timeout 5s;     # how long to wait for backend to accept connection
            proxy_send_timeout 60s;       # timeout when sending data to backend
            proxy_read_timeout 3600s;     # 1h for WebSocket or long responses

            # Optional for streaming apps
            # proxy_buffering off;         # disable buffering for real-time data
        }
    }
}